{-# LANGUAGE OverloadedStrings #-}
module Main where

import Control.Concurrent(threadDelay)
import Control.Concurrent.Async
import Control.Distributed.Process.Backend.SimpleLocalnet
import Control.Monad.Reader
import Data.Text as Text
import Data.Zya.Core.Service
import Data.Zya.Core.Subscription
import Data.Zya.Persistence.Persistence(DBType(..), ConnectionDetails(..), DBVendor(..))
import Data.Monoid ((<>))

import Data.Zya.Utils.Logger(setup, infoMessage)
import System.Log
{-- |
 A reference test client. Messages are generated by the test writer. The webserver publishes
 the stream.
 The system snapshot could comprise of
  . General health of the system: approximate number of messages processed in the last 1 minute for example.
  . Endpoint distribution: how ports are distributed for the webserver, so clients can connect to view the state.
--}
main :: IO ()
main = startServices


-- | A start service blue print should be 
-- something like below: 
-- Create 20 Writers using Postgres connection, 20 with sqllite
-- Create 40 WebServices, Create 20 compute node. 
-- Allow Max 100 WebServices, 100 Writers.
-- Minimum services required is 70% of each service.
-- For example,  if the service count is less than 28, the system
-- needs to send a kill signal to all the components so 
-- as to enable recovery.
  
componentName :: Text
componentName = "Zya.Main"
startServices :: IO ()
startServices =  do
  setup DEBUG
  infoMessage $ (pack "Starting services")
  test <- testBackend
  --ta <- async $ cloudEntryPoint test (TopicAllocator, debugServiceName, fst debugConnStr, snd debugConnStr, Nothing)
  let nWriters = 6
  let messages = 1000 -- Messages to be published.
  let startPort = 30000
  let nWebServers = 5
  let nQueryServices = 3 :: Int
  queryServices <-
    forM[1..nQueryServices] $ \_ ->
        async $ cloudEntryPoint test (QueryService, debugServiceName, fst debugConnStr, snd debugConnStr, Just (nWriters * messages), -1)

  threadDelay(10 ^ 6 * 3 :: Int)
  writers <- forM [1..nWriters] $ \_ -> async $ cloudEntryPoint test (Writer, debugServiceName, fst debugConnStr, snd debugConnStr, Just messages, -1)

  testWriter <- async $ cloudEntryPoint test (TestWriter, debugServiceName, fst debugConnStr,  snd debugConnStr, Just messages, -1)
  webServers <-
    forM[1..nWebServers] $ \ i ->
      async $ cloudEntryPoint test (WebServer, debugServiceName, fst debugConnStr, snd debugConnStr, Just messages, startPort + i)


  computeNode <- async $ cloudEntryPoint test (ComputeNode, debugServiceName, fst debugConnStr,  snd debugConnStr, Just messages, -1)

  void . waitAny $ writers <> webServers <> [testWriter] <> queryServices



-- A test backend
testBackend :: IO Backend
testBackend = simpleBackend "localhost" "5000"

type Version = [Int]
isRecent :: (Ord a) => a -> a -> Bool
isRecent = (<)

debugConnStrSqlite :: (DBType, ConnectionDetails)
debugConnStrSqlite = (RDBMS Sqlite, ConnectionDetails ":memory:")


debugConnStrPostgres :: (DBType, ConnectionDetails)
debugConnStrPostgres =
    (RDBMS Postgresql, ConnectionDetails "host=localhost dbname=zya_debug user=zya_debug password=zya_debug port=5432")

debugConnStr :: (DBType, ConnectionDetails)
--debugConnStr = debugConnStrPostgres
debugConnStr = debugConnStrSqlite
newtype TServiceName = TServiceName {_unName :: String} deriving Show
debugServiceName :: Text
debugServiceName =
    let s = TServiceName "testZYA" in
    Text.pack $ _unName s
